<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Lu小白的进阶之路：Java基础篇 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Hello world!Java语言知识、类与对象、类的重用、接口与多态、输入输出、对象群体的组织、图形用界面">
<meta property="og:type" content="article">
<meta property="og:title" content="Lu小白的进阶之路：Java基础篇">
<meta property="og:url" content="http://yoursite.com/2020/07/15/Java%E5%9F%BA%E7%A1%80%E7%AF%87/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Hello world!Java语言知识、类与对象、类的重用、接口与多态、输入输出、对象群体的组织、图形用界面">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="c:/Users/aloha/AppData/Roaming/Typora/typora-user-images/image-20200804143838254.png">
<meta property="article:published_time" content="2020-07-15T09:11:43.000Z">
<meta property="article:modified_time" content="2020-08-05T06:26:33.639Z">
<meta property="article:author" content="Sam Lu">
<meta property="article:tag" content="小白基础">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:/Users/aloha/AppData/Roaming/Typora/typora-user-images/image-20200804143838254.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Java基础篇" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/15/Java%E5%9F%BA%E7%A1%80%E7%AF%87/" class="article-date">
  <time datetime="2020-07-15T09:11:43.000Z" itemprop="datePublished">2020-07-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Lu小白的进阶之路：Java基础篇
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>Hello world!<br>Java语言知识、类与对象、类的重用、接口与多态、输入输出、对象群体的组织、图形用界面</p>
</blockquote>
<a id="more"></a>
<h2 id="1-Java语言基础知识"><a href="#1-Java语言基础知识" class="headerlink" title="1. Java语言基础知识"></a>1. Java语言基础知识</h2><pre><code>1.  java数据类型（ byte short int long float double char boolean 对象 ）</code></pre>
<p><strong>(1) 基本数据类型</strong><br>  <em>1.整数类型</em><br>   byte 占1字节（1字节 = 8位）-128 ~ 127<br>   short 占2字节<br>   int 占4字节<br>   long 占8字节<br>  <em>2.浮点类型</em><br>   float 占4字节 1.4e-45 ~ 3.4e+38<br>   double 占8字节 4.9e-324 ~ 1.8e+308<br>  <em>3.字符类型</em>        char ‘’<br>  <em>4.布尔类型</em>        boolean 取值只有true false两种</p>
<p><strong>(2) 引用类型</strong><br> <em>对象</em><br>  String是一个类，可以直接使用 String str = “hello world”</p>
<pre><code> 2.  java数组（ 一维数组 多维数组 ）</code></pre>
<p>声明 int[] a;<br>创建 a = new int[5];<br>分配内存 new为对象分配内存空间<br>使用 a[0] = 1;</p>
<pre><code> 3.  算法的流程控制</code></pre>
<p>if - else系列 选择分支结构<br>switch 选择分支结构</p>
<p>for 循环 （还有一种java专有的for增强版）<br>while 循环<br>do{}while 循环</p>
<p>break 跳出循环<br>continue 结束本次循环，回到下一轮循环初始位置</p>
<h2 id="2-类与对象"><a href="#2-类与对象" class="headerlink" title="2. 类与对象"></a>2. 类与对象</h2><pre><code>1 - 面向对象方法的特性 ---- 抽象、封装、继承、多态</code></pre>
<p>抽象：数据（属性）、方法（行为）<br>封装：隐藏细节，设计者与使用者分开<br>继承：基于已有类产生新类的机制；java仅支持单继承<br>多态：…… 子类对父类方法的覆盖等</p>
<pre><code>2 - 类与对象基础</code></pre>
<p>类的声明、对象的创建、数据成员、方法成员、包、类的访问权限控制、类成员的访问控制权限</p>
<p>i）类是对一类对象的描述；对象是类的具体实例；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类声明 、、[]可以没有</span></span><br><span class="line">[<span class="keyword">public</span>][<span class="keyword">abstract</span> | <span class="keyword">final</span>] <span class="class"><span class="keyword">class</span> 类名称 //公有类、抽象类、终结类</span></span><br><span class="line">[extends 父类名称]</span><br><span class="line">[implements 接口名称列表] <span class="comment">//如果声明的类要实现某些接口</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  数据成员声明及初始化;        <span class="comment">//类变量和实例变量</span></span><br><span class="line">                    [<span class="keyword">public</span> | <span class="keyword">protected</span> | <span class="keyword">private</span>]<span class="comment">//访问控制符</span></span><br><span class="line">                    [<span class="keyword">static</span>][<span class="keyword">final</span>][<span class="keyword">transient</span>][<span class="keyword">volatile</span>]</span><br><span class="line">                    <span class="comment">//静态成员变量（类变量）、变量值不能被修改、变量不需要序列化、共享变量</span></span><br><span class="line">                    数据类型 变量名[=变量初值];</span><br><span class="line">                    </span><br><span class="line">  方法声明及方法体;        <span class="comment">//类的方法和实例方法</span></span><br><span class="line">                    [<span class="keyword">public</span> | <span class="keyword">protected</span> | <span class="keyword">private</span>]</span><br><span class="line">                    [<span class="keyword">static</span>][<span class="keyword">final</span>][<span class="keyword">abstract</span>][<span class="keyword">native</span>][<span class="keyword">synchronized</span>]</span><br><span class="line">                    <span class="comment">//native用来集成java代码和其他语言的代码、</span></span><br><span class="line">                    <span class="comment">//synchronized用来控制多个并发线程对共享数据的访问</span></span><br><span class="line">                    返回类型 方法名([参数列表]) [<span class="keyword">throws</span> exceptionList]</span><br><span class="line">                      &#123;</span><br><span class="line">                        方法体</span><br><span class="line">                      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i）类变量，整个类中公共的变量，用<strong>static</strong>修饰；<br>实例变量，是类的成员变量，没被static修饰的变量；<br>i）类方法，<strong>static</strong>修饰，不能声明为抽象的；<br>实例方法，与实例变量一样，只能 &lt;实例名&gt;.&lt;方法名&gt; 进行类外调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对象引用声明</span></span><br><span class="line">类名 引用变量名;</span><br><span class="line"><span class="comment">//对象的创建</span></span><br><span class="line">引用变量名 = <span class="keyword">new</span> &lt;类名&gt;();</span><br><span class="line">=========<span class="comment">//所有的类都有一个默认的toString()方法，默认的toString()返回：</span></span><br><span class="line">=========<span class="comment">//getClass().getName()+&quot;@&quot;+Integer.toHexString(hashcode());//十六进制字符串</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可变长参数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">maxArea</span><span class="params">(Circle c, Rectangle... varRec)</span></span>&#123;</span><br><span class="line">    Rectangle[] rec = varRec;</span><br><span class="line">    <span class="keyword">for</span>(Rectangle r : rec)&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java编译器为所有程序自动引入包java.lang<br>静态引入：import static –</p>
<blockquote>
<p>类的成员访问权限控制<br>public：可以被其他任何方法访问（前提是对类成员所属的类有访问权限）<br>protected：只可被同一类及其子类的方法访问<br>private：只可被同一类的方法访问<br>默认default：仅允许同一个包内的访问，又被称为“包（package）访问权限”</p>
</blockquote>
<pre><code>3 - 对象初始化和回收</code></pre>
<ul>
<li><strong>==== 构造方法 ====</strong></li>
</ul>
<p>· 方法名与类名相同；<br>· 不定义返回类型；<br>· 通常被声明为共有的<strong>public</strong>；<br>· 可以有任意多个参数；<br>· 主要作用是完成对象的初始化工作<br>· 不能在程序中显示的调用<br>· 在生成一个对象时，会自动调用该类的构造方法为新对象初始化<br>· 若未显式声明构造方法，编译器隐含生成默认的构造方法</p>
<blockquote>
<p>默认构造方法:<br>没有参数（内部类除外），方法体为空；<br>使用默认的构造方法初始化对象时，如果在类声明中没有给实例变量赋初值，则对象的属性值为0或null；<br>构造方法可以被<strong>重载</strong>:<br>一个类中有两个及以上同名的方法，单参数表不同，这种情况就被称为<strong>方法重载</strong>。<br>可以使用<strong>this</strong>关键字重载构造方法，避免冗余。</p>
</blockquote>
<ul>
<li><strong>==== 对象的自动回收 ====</strong></li>
</ul>
<p>· 无用对象；</p>
<blockquote>
<p>离开了作用域的对象；<br>无引用指向的对象；</p>
</blockquote>
<p>· Java运行时系统通过 垃圾收集器 周期性地释放无用对象所使用的的内存；<br>· Java运行时系统会在对对象进行 自动垃圾回收前 ，自动调用对象的finalize()方法；</p>
<blockquote>
<p>在类java.lang.Object中声明，因此Java中每一个类都有finalize()方法<br>protected void finalize() throws throwable<br>用于释放资源。<br>类可以覆盖（重写）finalize()方法。<br>finalize()方法有可能在任何时机以任何次序执行。</p>
</blockquote>
<pre><code>4 - 枚举类型</code></pre>
<p>简单枚举类型、枚举类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">public</span>] <span class="keyword">enum</span> 枚举类型名称</span><br><span class="line"> [implements 接口名称列表]</span><br><span class="line">&#123;</span><br><span class="line">    枚举值;</span><br><span class="line">    变量成员声明及初始化;</span><br><span class="line">    方法声明及方法体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-类的重用"><a href="#3-类的重用" class="headerlink" title="3. 类的重用"></a>3. 类的重用</h2><pre><code>1 - 类的继承</code></pre>
<p>超类与子类。关键字<strong>extends</strong>；<br>子类不能直接访问从超类中继承的<strong>私有属性</strong>及方法，但可使用公有（及保护）方法进行访问；</p>
<blockquote>
<p><strong>隐藏 与 覆盖</strong><br>1）子类中重新声明与超类中<strong>相同名称</strong>的对象，则超类中的<strong>该属性（变量）被隐藏</strong>；<br> 可以用<strong>super</strong>关键字访问超类中的隐藏属性。<br>2）如果子类不需要从超类继承来的方法的功能，则可以声明自己的<strong>同名方法</strong>，称为<strong>方法覆盖</strong>；<br>· 覆盖方法的访问权限可以比被覆盖的宽松，但是不能更为严格。<br>· 派生类必须覆盖基类中的抽象的方法，否则派生类自身也成为抽象类；<br>基类中声明为<strong>final、或是static</strong>的方法不能被覆盖；<br>· super.overriddenMethodName(); //调用被覆盖的方法</p>
</blockquote>
<pre><code>2 - Object类</code></pre>
<blockquote>
<p>所有类的直接或间接超类，处在类层次最高点；<br>包含了所有Java类的公共属性。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/Object类的主要方法</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Class <span class="title">getClass</span><span class="params">()</span>     /获取当前对象所属类的信息，返回Class对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span>    /返回表示当前对象本身有关信息的字符串对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span>    /比较两个对象引用是否指向同一对象，是则返回<span class="keyword">true</span>，否则返回<span class="keyword">false</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span>    /复制当前对象，并返回这个副本</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span>    /返回该对象的哈希代码值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable    /在对象被回收时执行，通常完成的资源释放工作</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>相等和同一</strong><br>两个对象具有<strong>相同的类型，及相同的属性值</strong>，则称二者相等（equal）。<br>如果<strong>两个引用变量指向的是同一个对象</strong>，则称这两个引用变量同一（identical）。<br>i）两个对象同一，则肯定相等；<br>两个对象相等，不一定同一；<br>i）比较运算符“ == ”判断的是这两个对象是否同一。//判断的<strong>引用</strong><br>Object类里的equals()方法 比较的也是引用，所以equals()方法通常需要重写</p>
</blockquote>
<blockquote>
<p><strong>hashCode()方法</strong><br>hashCode是一个返回对象散列码的方法，一般规定：<br>i）在一个Java程序的一次执行过程中，如果对象“相等比较”所使用的信息没有被修改的话，同一对象执行hashCode方法每次都应返回同一个整数。在不同的执行中，对象的hashCode方法返回值不必一致。<br><strong>i）如果依照equals方法两个对象是相等的，则这两个对象上调用hashCode方法应该返回同样的整数结果。</strong><br>只要实现得合理，Object类定义的hashCode方法为不同对象返回不同的整数。<em>一个典型的实现是，将对象的内部地址转换为整数返回，但是Java语言并不要求必须这样实现。</em></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*clone方法</span></span><br><span class="line"><span class="comment">使用clone方法复制对象</span></span><br><span class="line"><span class="comment">1.覆盖clone方法：在Object类中被定义为protected，所以需要覆盖为public；</span></span><br><span class="line"><span class="comment">2.实现Cloneable接口，赋予一个对象被克隆的能力（cloneability）*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//···</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/finalize方法，如果要覆盖finalize方法，覆盖方法的最后必须调用<span class="keyword">super</span>.finalize</span><br></pre></td></tr></table></figure>
<blockquote>
<p>notify、notifyAll、wait方法；final方法，不能覆盖；这三个方法主要用在多线程程序中</p>
</blockquote>
<pre><code>3 - 终结类与终结方法</code></pre>
<p> i）用final修饰的类和方法；<br> i）终结类不能被继承；<br> i）终结方法不能被子类覆盖。</p>
<pre><code>4 - 抽象类</code></pre>
<p> i）类名前加修饰符abstract；<br> i）可包含常规类能包含的任何成员，包括非抽象方法；<br> i）也可包含抽象方法：用abstract修饰，只有方法原型，没有方法的实现；<br> i）没有具体实例对象的类，不能使用new方法进行实例化，只能用作超类；<br> i）只有当子类实现了抽象超类中的所有抽象方法，子类才不是抽象类，才能产生实例；<br> i）如果子类中仍有抽象方法未实现，则子类也只能是抽象类。</p>
<pre><code>5 - 泛型</code></pre>
<ul>
<li>类型也可以是参数；泛型类  泛型方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GeneralType</span> &lt;<span class="title">Type</span>&gt;</span>&#123;</span><br><span class="line">    Type object;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GeneralType</span><span class="params">(Type object)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.object = object;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Type <span class="title">getObj</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在泛型类中可以使用通配符?</span><br></pre></td></tr></table></figure></li>
<li>有限制的泛型，在参数“Type”后面使用”<strong>extends</strong>“关键字并加上类名或接口名，表明参数所代表的类型必须是该类的子类或者实现了该接口。（注意，对于实现了某接口的有限制泛型，也是使用extends关键字，而不是implements关键字）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GeneralType</span> &lt;<span class="title">Type</span> <span class="keyword">extends</span> <span class="title">Number</span>&gt;</span>&#123;</span><br><span class="line">    ··· <span class="comment">//Integer 是 Number 的子类，String不是</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<pre><code>6 - 类的组合</code></pre>
<ul>
<li>将已存在类的对象放到新类中即可<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cooker</span></span>&#123;<span class="comment">//类的语句&#125;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Refrigerator</span></span>&#123;<span class="comment">//类的语句&#125;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Kitchen</span></span>&#123;</span><br><span class="line">    Cooker myCooker;</span><br><span class="line">    Refrigerator myRefrigerator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="4-接口与多态"><a href="#4-接口与多态" class="headerlink" title="4. 接口与多态"></a>4. 接口与多态</h2><pre><code>1 - 接口</code></pre>
<p><strong>可以把接口看作纯的抽象类，它只提供设计</strong><br>i）接口（Interface ）中可以规定方法的原型：方法名、参数列表以及返回类型，但不规定方法主体；<br>i）也可以包含基本数据类型的数据成员，但它们都默认为static和final。</p>
<blockquote>
<p>接口的作用<br>1.继承多个设计<br>2.建立类和类之间的“协议”</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[接口修饰符] interface 接口名称 [extends 父接口名]&#123;</span><br><span class="line">    ...<span class="comment">//方法的原型声明或静态常量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i）接口的数据成员一定要有初值，且此值不能再更改，可以省略final关键字；<br>i）接口中的方法必须是“抽象方法”，不能有方法体，可以省略public及abstract关键字。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Shape2D</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> pi = <span class="number">3.14</span>;    <span class="comment">//数据成员一定要初始化，省略了final</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">area</span><span class="params">()</span></span>;    <span class="comment">//抽象方法，省略了public abstract</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实现接口：</strong>利用接口设计类的过程，成为接口的实现，使用implements关键字，语法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 类名称 <span class="keyword">implements</span> 接口名称 </span>&#123;</span><br><span class="line">    <span class="comment">//在类体中实现接口的方法</span></span><br><span class="line">    <span class="comment">//本类声明的更多变量和方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实现多个接口的语法：</strong>一个类可以实现多个接口，通过这种机制可实现对设计的多重继承；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[类修饰符] <span class="class"><span class="keyword">class</span> 类名称 <span class="keyword">implements</span> 接口1，接口2，...</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">... ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//声明Circle类实现接口Shape2D（见上）和Color</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Color</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setColor</span><span class="params">(String str)</span></span>; <span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape2D</span>, <span class="title">Color</span>    //实现<span class="title">Circle</span>类</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> radius;</span><br><span class="line">    String color;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> r)</span></span>&#123;    <span class="comment">//构造方法</span></span><br><span class="line">        radius = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">area</span><span class="params">()</span></span>&#123;    <span class="comment">//定义area()的处理方式</span></span><br><span class="line">        <span class="keyword">return</span> (pi * radius * radius);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(String str)</span></span>&#123;    <span class="comment">//定义setColor()的处理方式</span></span><br><span class="line">        color = str;</span><br><span class="line">        System.out.println(<span class="string">&quot;color=&quot;</span> + color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiTnterfaceTester</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Circle cir;</span><br><span class="line">        cir = <span class="keyword">new</span> Circle(<span class="number">2.0</span>);</span><br><span class="line">        cir.setColor(<span class="string">&quot;blue&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Area = &quot;</span> + cir.area());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>接口的扩展：</strong>实现一个接口的类也必须实现其超接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> 子接口的名称 <span class="keyword">extends</span> 超口的名称1，超口的名称2，...</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>2 - 类型转换</code></pre>
<p>1）基本数据类型转换<br>2）引用类型转换，类  接口<br>应用场景：赋值转换、方法调用转换、算术表达式转换、字符串转换</p>
<p>方法查找：实例方法的查找，类方法的查找</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其中Manager类继承至Employee类，两类中都分别有</span></span><br><span class="line">/实例方法computePay(); 类方法（静态方法）<span class="function"><span class="keyword">static</span> <span class="title">expenseAllowance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Mannager man </span>= <span class="keyword">new</span> Manager();</span><br><span class="line">Employee emp1 = <span class="keyword">new</span> Employee();</span><br><span class="line">Employee emp2 = (Employee)man;</span><br><span class="line"></span><br><span class="line">/实例方法的查找，从对象创建时的类开始，沿类层次向上查找</span><br><span class="line">emp1.computePay();    <span class="comment">//调用Employee类中的computePay()方法</span></span><br><span class="line">man.computePay();    <span class="comment">//调用Manager类中的computePay()方法</span></span><br><span class="line">emp2.computePay();    /调用Manager类中的computePay()方法</span><br><span class="line"></span><br><span class="line">/类方法的查找，总是在引用变量声明时所属的类中进行查找</span><br><span class="line">man.expenseAllowance();        <span class="comment">//in Manager</span></span><br><span class="line">emp1.expenseAllowance();    <span class="comment">//in Employee</span></span><br><span class="line">emp2.expenseAllowance();    /in Employee, 因为类方法不属于任何一个对象</span><br></pre></td></tr></table></figure>

<pre><code>3 - 多态的概念</code></pre>
<p>i）多态指的就是，不同类型的对象，它可以响应相同的消息，而各自对于这个消息的响应行为可以不同。</p>
<blockquote>
<p>超类对象和从相同的超类派生出来的多个子类对象，可被当作同一种类型的对象对待；<br>实现同一接口不同类型的对象，可被当作同一种类型的对象对待；<br>可向这些不同的类型对象发送同样的消息，由于多态性，这些<strong>不同类的对象</strong>响应同一消息时的行为可以有所差别。</p>
</blockquote>
<p>i）多态的目的：使代码变得简单且容易理解；使程序具有很好的可扩展性。<br>i）技术基础：动态绑定、向上转型</p>
<pre><code>4 - 多态的应用</code></pre>
<p>例：二次分发<br>double dispatching，即对输出消息的请求被分发两次；<br>首先根据驾驶员的类型被发送给一个类；<br>之后根据交通工具的类型被发送给另一个类。</p>
<pre><code>5 - 构造方法与多态</code></pre>
<blockquote>
<p>构造子类对象时构造方法的调用顺序：<br>1.首先调用超类的<strong>构造方法</strong>，这个步骤会不断重复下去，首先被执行的是最远超类的构造方法；<br>2.执行当前子类对象的构造方法体其他语句。</p>
</blockquote>
<p>构造方法中调用多态方法是有隐患的</p>
<blockquote>
<p>实现构造方法的注意事项：<br>1）用尽可能少的动作把对象的状态设置好；<br>2）如果可以避免，不要调用任何方法；<br>3）在构造方法内唯一能够安全调用的是超类中具有final属性的那些方法（也适用于private方法，它们自动具有final属性）。这些方法不能被覆盖，所以不会出现潜在问题。</p>
</blockquote>
<h2 id="5-输入输出"><a href="#5-输入输出" class="headerlink" title="5. 输入输出"></a>5. 输入输出</h2><pre><code>1 - 异常处理简介</code></pre>
<p><strong>异常，又称为例外，是特殊的运行错误对象。</strong><br>i）Java中声明了很多异常类，每个异常类都代表了一种运行错误，类中包含了：该运行错误的信息及处理错误的方法。<br>i）每当Java程序运行过程中发生一个可识别的运行错误时，即该错误有一个异常类与之对应时，系统都会产生一个相应的该异常类的对象，即产生一个异常。</p>
<blockquote>
<p>Java异常处理机制的优点：<br>1）将错误处理代码从常规代码中分离出来；<br>2）按错误类型和差别分组；<br>3）对无法预测的错误的捕获和处理；<br>4）克服了传统方法的错误信息有限的问题；<br>5）把错误传播给调用堆栈。</p>
</blockquote>
<p><strong>错误的分类：根据错误的严重程度不同，可以分为两类：</strong><br><strong>错误</strong>：致命性的，程序无法处理；<strong>Error类</strong>是所有错误类的父类；<br><strong>异常</strong>：非致命性的，可编制程序捕获和处理；<strong>Exception类</strong>是所有异常类的父类。</p>
<blockquote>
<p><strong>非检查型异常：</strong><br>1.不期望程序捕获的异常，在方法中不需要声明，编译器也不进行检查。<br>2.继承自RuntimeException。<br>3.不要求捕获和声明的原因：<br>引发RuntimeException的操作在Java应用程序中会频繁出现；<br>它们表示的问题不一定作为异常处理。<br><strong>检查型异常：</strong><br>1.其他类型的异常；<br>2.如果被调用的方法抛出一个类型为E的检查型异常，那么调用者必须捕获E或者也声明抛出E（或者E的一个父类），对此编译器要进行检查。</p>
</blockquote>
<p><strong>Java预定义的一些常见异常：</strong><br>i）非检查型异常：ArithmetricException（整数除法中除数为0）、NullPointerException（访问的对象还没有实例化）、NegtiveArraySizeException（创建数组时元素个数是负数）、ArrayIndexOutOfBoundsException（访问数组元素时，数组下标越界）···<br>i）检查性异常：FileNotFoundException（试图存取一个并不存在的文件）、IOException（通常的I/O错误）···</p>
<p><strong>检查型异常的处理：</strong><br>1）声明抛出异常<br>不在当前方法内处理异常，可以使用<strong>throws子句声明将异常抛出</strong>到调用方法中；<br>如果所有的方法都选择了抛出异常，最后JVM将捕获它，输出相关的错误信息，并终止程序的运行。<br>2）捕获异常<br>使用<strong>try{}catch(){}块</strong>，捕获到所发生的的异常，并进行相应的处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    可能产生异常的代码块</span><br><span class="line">&#125;<span class="keyword">catch</span>(exceptiontype name)&#123;</span><br><span class="line">    异常处理语句，通常要用到两个方法：</span><br><span class="line">    getMessage() - 返回一个字符串，对发生的异常进行描述；</span><br><span class="line">    printStackTrace() - 给出方法的调用序列，一直到异常的产生位置。</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    不论在<span class="keyword">try</span>代码段里是否发生异常，<span class="keyword">finally</span>后的程序代码段都会被执行。通常在这里释放内存以外的其他资源。</span><br><span class="line">&#125;</span><br><span class="line">/如果并列有多个<span class="keyword">catch</span>语句捕获多个异常，则一般的异常类型放在后面，特殊的放在前面。</span><br></pre></td></tr></table></figure>
<p><strong>生成异常对象</strong><br>1）由Java虚拟机生成；<br>2）由Java类库中的某些类生成；<br>3）在自己写的程序中生成和抛出异常对象。<br>抛出异常对象都是通过throw语句实现，异常对象必须是Throwable或其子类的实例：throw new ThrowableObject();</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">声明自己的异常类：自定义的所有异常类都必须是Exception的子类</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyExceptionName</span> <span class="keyword">extends</span> <span class="title">SuperclassOfMyException</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">&quot;Some string explaining the exception&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>2 - 输入、输出流的概念</code></pre>
<p><strong>预定义的 I/O流类</strong><br>i）从流的方向划分：输入流、输出流；<br>i）从流的分工划分：节点流、处理流；<br>i）从流的内容划分：面向字符的流（专门用于字符数据）、面向字节的流（用于一般目的）；</p>
<blockquote>
<p>面向字符的流：<br>1）源或目标通常是文本文件；<br>2）实现内部格式（16-bit char 数据类型）和文本文件中的外部格式（UTF、包括ASCII码及非ASCII码字符）之间转换</p>
</blockquote>
<blockquote>
<p><strong>面向字符的抽象流类–Reader和Writer</strong><br>1）java.io包中所有字符流类的抽象超类<br>2）Reader、Writer分别提供了输入、输出字符的API<br>3）它们的子类又可分为两大类：<br>ii）节点流：从数据源读入数据或往目的地写出数据；<br>ii）处理流：对数据执行某种处理。<br>4）多数程序使用这两个抽象类的一系列子类来读入/写出文本信息<br> 比如FileReader/FileWriter用来读/写文本文件。<br><strong>面向字节的抽象流类–InputStream和OutputStream</strong><br>是用来处理字节流的抽象基类，程序使用这两个类的子类来读写字节信息<br>分为节点流、处理流</p>
</blockquote>
<p>System类的静态成员变量：<br>i）<strong>System.in</strong>：InputStream类型的，代表<strong>标准输入流</strong>，默认状态对应于显示器输出。<br>i）<strong>System.out</strong>：PrintStream类型的，代表<strong>标准输出流</strong>，默认状态对应于显示器输出。<br>i）<strong>Syetem.err</strong>：PrintStream类型的，代表<strong>标准错误信息输出流</strong>，默认状态对应于显示器输出。</p>
<p><strong>按类型输入/输出数据</strong><br>i）printf方法：<br>System.out.printf(“%-12s is %d long”, name, l);<br>System.out.printf(“value = %2.2F”, value);<br>%n 是平台无关的换行标志。<br><strong>i）Scanner</strong><br>Scanner s = new Scanner(System.in);<br>int n = s.nextInt();<br>还有下列方法：nextByte(),    nextDouble(),    nextFloat(),    nextInt(),    nextLine(),    nextLong(),    nextShort().</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">标准输入/输出重定向（复制文件）</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Redirecting</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(string[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//将输入关联到磁盘文件，默认是键盘输入</span></span><br><span class="line">        BufferedInputStream in = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;Redirecting.java&quot;</span>));</span><br><span class="line">        <span class="comment">//将输出关联到另一磁盘文件，默认是显示器输出</span></span><br><span class="line">        PrintStream out = <span class="keyword">new</span> PrintStream(<span class="keyword">new</span> BufferedOutStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test.out&quot;</span>)));</span><br><span class="line">        <span class="comment">//重新定向</span></span><br><span class="line">        System.setIn(in);</span><br><span class="line">        System.setOut(out);</span><br><span class="line">        System.setErr(out);</span><br><span class="line">        <span class="comment">//缓冲流是输入效率更高，但不执行读取操作，是处理流，InputStreamReader是字节流与字符流的一个桥梁，属于面向字符的输入流</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">while</span>((s = br.readLine()) != <span class="keyword">null</span>)</span><br><span class="line">            System.out.printLn(s);    <span class="comment">//完成复制</span></span><br><span class="line">        in.close();</span><br><span class="line">        out.close();    <span class="comment">//关闭流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>3 - 文件读写</code></pre>
<p><strong>1）写文本文件</strong><br>创建：FileWriter writer = new FileWriter(fileName, true);<br>写入：writer.write(“Hello!\n”);    ···<br>关闭：writer.close();    //写入结束</p>
<p> \n在不同的平台不一定代表换行，可以使用<br>创建：<strong>BufferedWriter writer = new BufferedWriter(new FileWriter(fileName));</strong><br>写入：writer.write(“Hello!”);<br><strong>writer.newLine();</strong><br>关闭：writer.close();</p>
<p><strong>2）读文本文件</strong><br>i）FileReader类：从文本文件中读取字符；继承自Reader抽象类的子类InputStreamReader。<br><strong>i）BufferedReader</strong>：读文本文件的缓冲器类；具有readLine()方法，可以对换行符进行鉴别，一行一行地读取输入流中的内容；继承自Reader。<br>注：close()方法在写入时最好有（调用flush()方法不一定写入成功），在读取时主要是为了节省系统资源。</p>
<p><strong>3）写二进制文件</strong><br>二进制文件写入更快，占用空间更小；<br>抽象类OutoutStream<br>1）派生类FileOutputStream：<br>用于一般目的输出（非字符输出）；<br>用于成组字节输出。<br>2）<strong>派生类DataOutputStream：</strong><br>具有写个种基本数据类型的方法；writeInt() ···<br>将数据写到另一个输出流；<br>它在所有计算机平台上使用同样的数据格式；<br>其中size方法，可作为计数器，统计写入的字节数。</p>
<p>BufferedOutputStream类<br>DataOutputStream out = new DataOutputStream(new BufferedOutputStream(new FileOutputStream(fileName)));</p>
<p><strong>4）读二进制文件</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">通过捕获异常控制读取结束</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataInputStreamTester</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String fileName = <span class="string">&quot;data1.dat&quot;</span>;</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            DataInputStream instr = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(fileName)));</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">                    sum += instr.readInt();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span>(EOFException eof)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;The sum is:&quot;</span> + sum);</span><br><span class="line">            instr.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(IOException iox)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;IO problems with&quot;</span> + fileName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以用字节流读取文本文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InputStreamTeater</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileInputStream s = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;Hello.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> c;</span><br><span class="line">        <span class="keyword">while</span>((c = s.read()) != -<span class="number">1</span>) <span class="comment">//读取字节，结束返回-1</span></span><br><span class="line">            System.out.write(c);</span><br><span class="line">        s.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">read()方法读取一个字节，转化为[<span class="number">0</span>, <span class="number">255</span>]的之间的一个整数，返回一个<span class="keyword">int</span>。如果读到了文件末尾，则返回-<span class="number">1.</span></span><br><span class="line">write()方法写一个字节的低<span class="number">8</span>位，忽略高<span class="number">24</span>位。</span><br></pre></td></tr></table></figure>
<p><strong>读写字节</strong><br>1）DataOutputStream的writeByte方法：<br>public final void writeByte(int b) throws IOException<br>将int的最不重要字节写入输出流。<br>2）DataInputStream的readUnsignedByte方法：<br>public final int readUnsignedByte() throws IOException<br>从输入流中读取1字节存入int的最不重要字节。</p>
<p><strong>5）File类</strong><br>i）创建、删除文件；<br>i）重命名文件；<br>i）判断文件的读写权限及是否存在；<br>i）设置和查询文件的最近修改时间等；<br>i）构造文件流可以使用File类的对象作为参数。</p>
<blockquote>
<p>File f = new File(“Hello.txt”);</p>
</blockquote>
<p><strong>6）处理压缩文件</strong><br>压缩流类<br>1）GZIPOutputStream和ZipOutputStream<br>可分别把数据压缩成GZIP格式和Zip格式<br>2）GZIPInputStream和ZipInputStream<br>可以分别把压缩成GZIP格式或Zip的数据解压缩恢复原状</p>
<p><strong>7）对象序列化</strong><br>实现对象的读写<br>i）通过ObjectOutputStream把对象写入磁盘文件<br>i）通过ObjectInputStream把对象读入程序<br>不保存对象的transient和static类型的变量<br>对象要想实现序列化，其所属的类必须实现Serializable接口</p>
<blockquote>
<p>注：ObjectOutputStream和ObjectInputStream都是处理流，要通过节点流来构造：<br>FileOutputStream out = new FileOutputStream(“the Time”);<br>ObjectOutputStream s = new ObjectOutputStream(out);</p>
</blockquote>
<p><strong>Serielizable</strong><br>1）Serializable接口的定义<br>package java.io;<br>public interface Serializable{<br>   // there’s nothing in hear!<br>}<br>2）实现Serializable接口的语句<br>public class MyClass implements Serializable {<br>   ···<br>}<br>3）使用关键字<strong>transient</strong>可以阻止对象的某些成员被自动写入文件</p>
<p><strong>Externalizable</strong>接口<br>1）API中的说明为<br>public interface Externalizable extends Serializable<br>2）其中有两个方法writeExternal()和readExternal()，因此实现该接口的类必须实现这两个方法<br>3）ObjectOutputStream的writeObject()方法只写入对象的标识，然后调用对象的所属类的writeExternal()<br>4）ObjectInputStream的readObject()方法调用对象所属类的readExternal()</p>
<p><strong>8）随机文件读写</strong><br>RandomAccessFile类<br>i）可跳转到文件的任意位置读/写数据<br>i）可在随机文件中插入数据，而不是破坏该文件的其他数据<br>i）实现了DataInput和DataOutput接口，可使用普通的读写方法<br>i）有个位置指示器，指向当前读写处的位置。刚打开文件时，文件指示器指向文件的开头处。对文件指针显示操作的方法有：<br>  int skipBytes(int n)：把文件指针向前移动指定的n个字节<br>  void seek(long)：移动文件指针到指定的位置<br>  long getFilePointer()：得到当前的文件指针<br>i）在等长记录格式文件的随机读取时有很大的优势，但仅限于操作文件，不能访问其它IO设备，如网络、内存映像等</p>
<h2 id="6-对象群体的组织"><a href="#6-对象群体的组织" class="headerlink" title="6. 对象群体的组织"></a>6. 对象群体的组织</h2><pre><code>1 - Java集合框架介绍</code></pre>
<p>1）对外的接口：表现集合的抽象数据类型<br>2）接口的实现：指实现集合接口的Java类，是可重用的数据结构<br>3）对集合运算的算法：是指执行运算的方法，例如在集合上进行查找和排序。</p>
<p><strong>集合框架接口：</strong><br>i）声明了对集合类型执行的一般操作<br>i）包括Collection、Set、List、Queue、SortedSet、Map、SortedMap<br><strong>Collection：Set （下：SortedSet）、List、Queue<br>Map：SortedMap</strong></p>
<p>Collection接口：声明了一组操作成批对象的抽象方法；实现它的类：AbstractCollection类。</p>
<p><img src="C:\Users\aloha\AppData\Roaming\Typora\typora-user-images\image-20200804143838254.png"></p>
<p><strong>Collection接口常用方法：</strong><br>1）查询方法<br>i）int size() - 返回集合对象中包含的元素个数<br>boolean isEmpty() - 判断集合对象中是否还包含元素，如果没有任何元素，则返回true<br>i）boolean contains(Object obj) - 判断对象是否在集合中<br>i）boolean containsAll(Collection c) - 判断方法的接受者对象是否包含集合中的所有元素</p>
<p>2）修改方法<br>i）boolean add(Object obj) - 向集合中增加对象<br>i）boolean addAll(Collection&lt;?&gt; c) - 将参数集合中的所有元素增加到接收者集合中<br>i）boolean remove(Object obj) - 从集合中删除对象<br>i）boolean removeAll(Collection c) - 将参数集合中的所有元素从接收者集合中删除<br>i）boolean retainAll(Collection c) - 在接收者集合中保留参数集合中的所有元素，其它元素都删除<br>i）void clear() - 删除集合中的所有元素</p>
<pre><code>2 - 接口及常用类概述</code></pre>
<p><strong>1 - Set接口</strong><br>  对equals和hashCode操作有了更强的约定，如果两个Set对象包含同样的元素，二者便是相等的。<br><strong>实现Set接口对的类：</strong><br>i）哈希集合（<strong>HashSet</strong>）及树集合（<strong>TreeSet</strong>）<br>i）其他：AbstractSet 等（见上图）<br>**<em>SortedSet接口**</em><br>  一种特殊的Set，其中的元素是升序排列的，还增加了与次序相关的操作，通常用于存放词汇表这样的内容，实现它的类：ConcurrentSkipListSet，TreeSet。</p>
<p><strong>2 - List接口</strong><br>  可包含重复元素，元素是有顺序的，每个元素都有一个index指（从0开始）标明元素在列表中的位置。<br><strong>实现List接口对的类：</strong><br>i）Vector：逐渐被弃用，子类有Stack<br>i）<strong>ArrayList</strong>：一种类似数组的形式进行存储，因此它的随机访问速度极快<br>i）<strong>LinkedList</strong>：内部实现是链表，适合于在链表中间需要频繁进行插入和删除操作<br>i）<strong>栈Stack</strong><br>i）其它：AbstractList等（见上图）</p>
<p><strong>3 - Queue接口</strong><br>  除了Collection的基本操作，队列接口另外还有插入、移除和查看操作；FIFO（先进先出）<br><strong>实现Queue接口对的类：</strong><br>i）<strong>LinkedList：</strong>同时也实现了List，先进先出<br>i）PriorityQueue：按元素值排序的队列<br>i）其它：AbstractQueue等（见上图）</p>
<p><strong>4 - Map接口</strong><br>  用于维护键/值对（key/value pairs），不能有重复的关键字，每个关键字最多只能映射到一个值，声明时可以带有两个参数，即Map&lt;K, V&gt;，其中K代表关键字的类型，V表示值的类型<br><strong>实现Map接口对的类：</strong><br>i）<strong>HashMap</strong><br>i）其它：AbstractMap等（见上图）<br>**<em>SortedMap接口**</em><br>  Map的子接口，一种特殊的Map，其中的关键字是升序排列的，通常用于词典和电话目录等。<br>  SortedMap&lt;K, V&gt;<br>  实现它的类：<strong>TreeMap</strong>，<strong>ConcurrentSkipListMap（支持并发）</strong></p>
<pre><code>3 - 常用算法</code></pre>
<p>  对集合运算的算法，大多数算法都是<strong>用于操作List对象</strong>，有两个（min和max）可用于任意集合对象。<br><strong>1 - 排序算法sort</strong><br>使List元素按照某种次序关系升序排列，<em>有两种形式</em>：<br>i）简单形式只是将元素按照自然次序排列，或者集合实现了Comparable接口；<br>i）第二种形式需要一个附加的Comparator对象作为参数，用于规定比较规则，可用于实现反序或特殊次序排序。<br>算法性能，快：时间复杂度nlog(n)；稳定。</p>
<p><strong>2 - 洗牌算法shuffle</strong><br>  以随机方式重排List元素，任何次序出现的几率都是相等的；在实现偶然性游戏的时候，这个算法很有用，例如洗牌。</p>
<p><strong>3 - 常规数据处理算法</strong><br>1）reverse：将一个List中的元素反向排列。<br>2）fill：用指定的值覆写List中的每一个元素，这个操作在重新初始化List时有用。<br>3）copy：接受两个参数，目标List和源List，将源中的元素复制到目标，覆写其中的内容。目标List必须至少与源一样长，如果更长，则多于部分内容不受影响。</p>
<p><strong>4 - 查找算法binarySearch</strong><br>  使用二分法在一个<strong>有序的List中</strong>查找指定元素；<em>有两种形式</em>：<br>i）第一种形式假定List是按照自然排序升序排列的；<br>i）第二种形式需要增加一个Comparator对象，表示比较规则，并假定List是按照这种规则排序的。<br>  检查集合是否实现了RandomAccess接口。是：二分法查找。否：线性查找。</p>
<p><strong>5 - 寻找最值</strong><br>  用于任何集合对象。min和max算法返回指定集合中的最小值和最大值，分别都<em>有两种形式</em>：<br>简单形式按照元素的自然顺序返回最值；<br>另一种形式需要附加一个ComParator对象作为参数，并按照Comparator对象指定的比较规则返回最值。</p>
<pre><code>4 - 数组实用方法</code></pre>
<p><strong>Array类</strong>，java.util.Arrays<br>常用方法：<br>i）fill(type[] a, type val)：给数组填充，就是简单地把一个数组全部或者某段数据填写成一个特殊的值；<br>i）equals(type[] a, type[] b)：实现两个数组的比较，<strong>相等</strong>时返回true；<br>i）sort(type[] a)：对数组排序；<br>i）binarySearch()：对数组元素进行二分法查找；<br>i）asList(T… a)：实现数组到ArrayList的转换<br>i）toString(基本类型或object数组引用)：实现数组到string的转换</p>
<pre><code>5 - 基于动态数组的类型（Vector，ArrayList）</code></pre>
<p><strong>Vector，ArrayList</strong><br>实现了Collection接口，能够存储相同类型（或具有相同的父类或接口）的对象；<br>不能存储基本类型（primitive）的数据，要将基本类型数据包裹在包裹类中。<br>其容量能够根据空间需要自动扩充；<br>增加元素方法的效率较高，除非空间已满（在这种情况下，在增加之前需要先扩充容量）。<br>Vector：集合框架中的遗留类，旧线程安全集合。<br><strong>ArrayList</strong>方法是非同步的，效率较高。<br>Java提供了线程安全集合：Java.util.concurrent包，映像、有序集、队列<br>  任何集合类通过使用同步包装器可以变成线程安全的：<br>  List<E> synchArrayList = Collections.synchronizedList(new ArrayList<E>());</p>
<pre><code>6 - 遍历Collection</code></pre>
<p>遍历 实现了Collection接口的集合：<br>i）通过Enumeration及Iterator接口遍历集合；<br>i）增强for循环遍历集合；<br>i）通过聚集操作遍历集合。</p>
<p><strong>1 - 通过Enumeration及Iterator接口遍历</strong></p>
<p><strong>1）Enumeration / Iterator</strong><br>i）能够从集合类对象中提取每一个元素，并提供了用于遍历元素的方法<br>i）Java中的许多方法（如elements()）都返回Enumeration类型的对象，而不是返回集合类对象<br>i）Enumeration接口不能用于ArrayList对象，而Iterator接口既可以用于ArrayList对象，也可以用于Vector对象。<br><strong>2）Iterator接口：</strong><br>i）是对Enumeration接口的改进，因此在遍历集合元素时，优先选用Iterator接口。<br>i）具有从正在遍历的集合中去除对象的能力。<br>i）具有如下三个实例方法：<br>· hasNext() – 判断是否还有元素<br>· next() – 取得下一个元素<br>· remove() – 去除一个元素。注意是从集合中去除最后调用next()返回的元素，而不是从Iterator类中去除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">String[] num = &#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>&#125;;</span><br><span class="line">Vector&lt;String&gt; aVector = <span class="keyword">new</span> Vector&lt;String&gt; (java.util.Arrays.asList(num));    <span class="comment">//数组--》 list --》vector</span></span><br><span class="line">Iterator&lt;String&gt; nums = aVector.iterator();</span><br><span class="line">···</span><br><span class="line">nums.hasNext()</span><br><span class="line">nums.next();</span><br><span class="line">nums.remove();</span><br></pre></td></tr></table></figure>

<p><strong>2 - 增强for循环遍历</strong><br>  for(Type a : 集合对象)<br>for(String s : aVector){System.out.println(s);}</p>
<p><strong>3 - 通过聚集操作遍历</strong><br>  聚集操作与lambda表达式一起使用。<br>假设有一个实现了Collection接口的myShapesCollection集合对象，有getColor()可以返回对象的颜色，getName()方法返回对象的名字，则遍历并输出红色对象的名字：<br>  myShapesCollection.stream().filter(e -&gt; e.getColor == Color.RED).forEach(e -&gt; System.out.println(e.getName()));</p>
<pre><code>7 - Map接口及其实现</code></pre>
<p>抽象方法主要有：<br><strong>1）查询方法</strong><br>· int size() – 返回Map中的元素个数<br>· boolean isEmpty() – 返回Map中是否包含元素，如不包含元素，则返回true<br>· boolean containsKey(Object key) – 判断给定的参数是否是Map中的一个关键字（key）<br>· boolean containsValue(Object val) – 判断给定的参数是否是Map中的一个值（value）<br>· Object get(Object key) – 返回Map中与给定关键字相关联的值（value）<br>· Collection values() – 返回包含Map中所有值（value）的Collection对象<br>· Set keySet() – 返回包含Map中所有关键字（key）的Set对象<br>· Set entrySet() – 返回包含Map中所有项的Set对象</p>
<p><strong>2）修改方法</strong><br>· Object put(Object key, Object val) – 将给定的关键字（key）/值（value）对加入到Map对象中。其中关键字key必须唯一，否则，新加入的值会取代Map对象中已有的值<br>· void putAll(Map m) – 将给定的参数Map中的所有项加入到接受者Map对象中<br>· Object remove(Object key) – 将关键字为给定参数的项从Map对象中删除<br>· void clear() – 从Map对象中删除所有的项</p>
<p>两个主要实现类：HashTable、HashMap</p>
<p>i）<strong>哈希表存储对象的方式</strong>：对象的位置位置和对象的关键属性k之间有一个特定的对应关系f，我们称之为哈希（Hash）函数。它使得每个对象与一个唯一的存储位置相对应。因而在查找时，只要根据待查对象的关键属性k，计算f(k)的值即可知其存储位置。<br>i）<strong>哈希码（hash code）</strong>– 要将对象存储到HashTable结构，就需要将其关键字key映射到一个整型数据，称为key的哈希码。<br>i）<strong>装填因子</strong> – 默认0.75</p>
<h2 id="7-图形用户界面"><a href="#7-图形用户界面" class="headerlink" title="7. 图形用户界面"></a>7. 图形用户界面</h2><pre><code>1 - 绘图</code></pre>
<p><strong>1）图形环境和图形对象</strong><br><strong>坐标</strong>：GUI组件的左上角坐标默认为（0,0），从左上角到右下角，水平坐标x和垂直坐标y增加，坐标的单位是像素。<br><strong>Graphics对象</strong>：专门管理图形环境。Graphics类是一个抽象类，提供了一个与平台无关的绘图接口；各平台上实现的Java系统将创建Graphics类的一个子类，来实现绘图功能，但是这个子类对程序员是透明的；<u>在执行paint方法时，系统会传递一个指向特定平台的Graphics子类的图形对象g</u>。</p>
<p><strong>2）颜色</strong><br>Color类，以及Graphics类中与颜色有关的方法<br>public final static Color RED<br>public Color(int r, int g, int b)<br>public int getRed()  //返回某颜色对象的红色分量值（0~255）<br>Graphics：public void setColor(Color c)  //用于设置组件的颜色<br>Graphics：public Color getColor()  //用于获得组件的颜色</p>
<p><strong>3）字体</strong><br>Font类，以及Graphics类中与颜色有关的方法<br>public final static int PLAIN    （BOLD、ITALIC）<br>public Font(String name, int style, int size)<br>public int getStyle()<br>public Boolean isPlain()<br>Graphics：public void setFont(Font f)  //设置当前字体为f为指定的字体、风格和大小<br>Graphics：public Font getFont()  //获得当前字体</p>
<p><strong>4）Graphics类</strong><br>public void drawString(String str, int x, int y)<br>···方法很多</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.swing.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> clss GraphicsTester extends JFrame &#123; <span class="comment">//继承JFrame，构造窗口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GraphicsTester</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">&quot;演示字体、颜色、绘图&quot;</span>)；</span><br><span class="line">        setVisible(<span class="keyword">true</span>);  <span class="comment">//显示窗口</span></span><br><span class="line">        setSize(<span class="number">480</span>, <span class="number">250</span>);  <span class="comment">//设置窗口大小</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paint</span><span class="params">(Graphics g)</span> </span>&#123;   <span class="comment">//非抽象类子类引用</span></span><br><span class="line">        <span class="keyword">super</span>.paint(g);  <span class="comment">//将引用传给超类</span></span><br><span class="line">        <span class="comment">//Graphics2D g2d = (Graphics2D)g;</span></span><br><span class="line">        g.setFont(<span class="keyword">new</span> Font(<span class="string">&quot;SansSerif&quot;</span>, Font.BOLD, <span class="number">12</span>));</span><br><span class="line">        g.setColor(Color.blue);  <span class="comment">//设置颜色</span></span><br><span class="line">        g.drawString(<span class="string">&quot;hello&quot;</span>, <span class="number">20</span>, <span class="number">50</span>);</span><br><span class="line">        </span><br><span class="line">        g.drawLine(<span class="number">20</span>, <span class="number">60</span>, <span class="number">460</span>, <span class="number">60</span>); <span class="comment">//绘制直线</span></span><br><span class="line">        ···</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        GraphicsTester application = <span class="keyword">new</span> GraphicsTester();</span><br><span class="line">        application.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); <span class="comment">//关闭窗口操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>5）Java2D API</strong><br>提供了<em>高级的二维图形功能</em>；分布在java.awt、java.awt.image、···多个包中<br>Graphics2D类：是Graphics类的抽象子类；要使用Java2D API，就必须建立该类的对象<br>  传递给paint方法的对象是Graphics2D的一个子类实例，被向上转型为Graphics类的实例。要访问Graphics2D的功能，必须将传递给paint方法的Graphics引用强制转换为Graphics2D引用：Graphics2D g2d = (Graphics2D)g;</p>
<pre><code>2 - Swing基础</code></pre>
<p>1）JFC与Swing<br>JFC（Java Foundation Classes）：是关于GUI组件和服务的完整集合。作为JAVA SE的一个有机部分，主要包含5个部分，AWT、Java2D、Accessibility、Drag &amp; Drop、Swing。<br>Swing：JFC的一部分，提供按钮、窗口、表格等所有的组件；纯Java组件(用java写的)。</p>
<pre><code>3 - Swing的层次</code></pre>
<p>java.swing.JComponent –&gt; java.awt.Container –&gt; java.awt.Component –&gt; java.lang.Object<br>  Component类、Container类；JComponent类 – 多数Swing组件的超类<br>  Swing的组件和容器层次：顶层容器、中间层容器、原子组件。<br><strong>顶层容器：</strong><br>i）JFrame实现单个主窗口，JDialog实现一个二级窗口（对话框），JApplet在浏览器窗口中实现一个applet显示区域。<br>i）必须和操作系统打交道，所以都是重量级组件。从继承结构来看，他们分别是从原来AWT组件的Frame、Dialog和Applet类继承而来。<br><strong>i）每个实用Swing组件的Java程序都必须至少有一个顶层容器</strong>，别的组件都必须放在这个顶层容器上才能显现出来。</p>
<p>布局管理，布局管理器</p>
<pre><code>4 - 内部类</code></pre>
<p>i）在另一个类或方法的定义中定义的类<br>i）可访问其外部类中的所有数据成员和方法成员<br>i）可对逻辑相互联系的类进行分组<br>i）对于同一个包中的其他类来说，能够隐藏<br>i）可非常方便地编写事件驱动程序<br>i）声明方式：<br>  命名的内部类：可在类的内部多次使用<br>  匿名内部类：可在new关键字后声明内部类，并立即创建一个对象<br>i）假设外层类名为Myclass，则该类的内部类名为：<br>  Myclass$c1.class(c1为命名的内部类名)<br>  Myclass$1.class(1表示类中声明的第一个匿名内部类)</p>
<pre><code>5 - 事件处理</code></pre>
<p><strong>1）常见的事件包括：</strong><br>移动鼠标<br>单双击鼠标各个按钮<br>单击按钮<br>在文本字段输入<br>在菜单中选择菜单项<br>在组合框中选择、单选和多选<br>拖动滚动条<br>关闭窗口<br>······<br>Swing通过事件对象来包装事件，程序可以通过事件对象获得事件的有关信息</p>
<p><strong>2）事件处理的几个要素</strong><br><strong>事件源</strong>：与用户进行交互的GUI组件，表示时间来自哪个组件或对象<br><strong>事件监听器</strong>：负责监听事件并做出响应，一旦它监视到事件发生，就会自动调用相应的事件处理程序作出响应。<br><strong>事件对象</strong>：封装了有关已发生的事件的信息，例如按钮被按下就是一个要被处理的事件，当用户按下按钮时，就会产生一个事件对象。事件对象包含事件的相关信息和事件源。</p>
<p>3）事件派发机制<br>Swing中的组件是非线程安全的，在Swing中专门提供了一个<strong>事件派发线程（EDT）</strong>用于对组件的安全访问。<br>可以调用invokeLater或invokeAndWait请事件分发线程以运行某段代码，要将这段代码放入一个Runnable对象的run方法中，并将该Runnable对象作为参数传递给invokeLater。<br>invokeLater是异步的，不用等代码执行完就返回。<br>invokeAndWait是同步的，要等代码执行完才返回，调用时要避免死锁。</p>
<pre><code>6 - Swing组件</code></pre>
<p>顶层容器<br>中间层容器<br>  一般用途的：JPanel、JScrollPane、JSpiltPane、JTabbedPane、JToolBar<br>  特殊用途的：JInternalFrame、JRootPane（这个可以直接从顶层容器中获得）<br>原子组件<br>  显示不可编辑信息：JLabel、JProgressBar、JToolTip<br>  有控制功能、可以用来输入信息：JButton、JCheckBox、······<br>  能提供格式化的信息并允许用户选择：JColorChooser、JFileChooser、JTable、JTree</p>
<pre><code>7 - 其它Swing特性</code></pre>
<p>Action对象</p>
<p>边框</p>
<p>设置组件的观感</p>
<p>设置顶层容器的观感</p>
<pre><code>8 - 桌面API简介</code></pre>
<p>从Java6开始，对于特定的文件类型，Java程序可以和关联该文件类型的主机应用程序进行交互。这种交互是通过java.awt.DeskTop类进行的，因此java.awt.DeskTop API叫做桌面API</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        system.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/15/Java%E5%9F%BA%E7%A1%80%E7%AF%87/" data-id="ckdlqfk2e001dbcul3rudcl3g" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B0%8F%E7%99%BD%E5%9F%BA%E7%A1%80/" rel="tag">小白基础</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/07/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Lu小白的进阶之路：计算机网络
        
      </div>
    </a>
  
  
    <a href="/2020/07/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Lu小白的进阶之路：数据结构</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JZ/" rel="tag">JZ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/job/" rel="tag">job</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E7%99%BD%E5%9F%BA%E7%A1%80/" rel="tag">小白基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9A%8F%E7%AC%94/" rel="tag">随笔</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JZ/" style="font-size: 16.67px;">JZ</a> <a href="/tags/java/" style="font-size: 20px;">java</a> <a href="/tags/job/" style="font-size: 13.33px;">job</a> <a href="/tags/%E5%B0%8F%E7%99%BD%E5%9F%BA%E7%A1%80/" style="font-size: 16.67px;">小白基础</a> <a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size: 10px;">随笔</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/08/08/%E5%89%91%E6%8C%87offer%E4%B9%A0%E9%A2%98%E5%85%AB%EF%BC%8836-40%EF%BC%89/">剑指offer习题八（36-40）</a>
          </li>
        
          <li>
            <a href="/2020/08/05/%E5%89%91%E6%8C%87offer%E4%B9%A0%E9%A2%98%E4%B8%83%EF%BC%8831-35%EF%BC%89/">剑指offer习题七（31-35）</a>
          </li>
        
          <li>
            <a href="/2020/08/03/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2020/07/29/%E5%89%91%E6%8C%87offer%E4%B9%A0%E9%A2%98%E5%85%AD%EF%BC%8826-30%EF%BC%89/">剑指offer习题六（26-30）</a>
          </li>
        
          <li>
            <a href="/2020/07/28/%E5%89%91%E6%8C%87offer%E4%B9%A0%E9%A2%98%E4%BA%94%EF%BC%8821-25%EF%BC%89/">剑指offer习题五（21-25）</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Sam Lu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>